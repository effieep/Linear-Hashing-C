# Linear-Hashing-C

## Επεξήγηση  σχεδιασμού εφαρμογής mvote

    - Σχετικά με τον σχεδιασμό της δομής hash_table:

    Αρχικά, αρχικοποιώ το hash table με αρχικό αριθμό buckets m και ύστερα ξεκινάει η εισαγωγή των κλειδιών.

        Έχουμε τον δέκτη ht ή hash_table να είναι ο δυναμικός πίνακας των buckets π.χ. O ht[o] δείχνει στο bucket O. To struct bucket περιέχει έναν δείκτη σε struct Pair
    (δέκτης σε participant και κλειδί (pin) του αντίστοιχου participant) και ένα δείκτη σε struct bucket, ο οποίος προορίζεται για τα overflown buckets που ενδεχομένως
    να προκύψουν κατά την εισαγωγή των κλειδιών.
        Τα overflown buckets στην ουσιά είναι μια συνδεδεμένη λίστα με head το main bucket (π.χ. ht[5]). Ο δείκτης αυτός κατά την αρχικοποίηση του Bucket αρχικοποιείται σε 
    NULL, το οποίο υποδεικνύει ότι δεν έχει προκύψει overflow.

    -> Εισαγωγή κλειδιού με linear hashing

        Στην περίπτωση που ο  load factor (keys inserted/ capacity (=bucketentries * buckets)) ξεπεράσει την τιμή 0.75, πρέπει να γίνει split του κατάλληλου bucket.
    Για να γνωρίζουμε ποιο bucket πρέπει να γίνει split, ένας ακέραιος split αρχικοποιείται με 0 που υποδεικνύει τον index του hash_table. Π.χ. Αν split = 1, το ht[1]
    bucket πρέπει να γίνει split. Κατά τη διάδικασία του splitting τα κλειδιά που υπάρχουν στο bucket γίνονται redistribute στο hash hash_table χρησιμοποιώντας την 
    επόμενη hash_function από αυτή που χρησιμοποιείται τη συγκεκριμένη στιγμή.
        Στην περίπτωση που ένα overflown bucket αδειάσει κατά τη διαδικασία του split τότε πρέπει να γίνει deallocate.

        Η χρήση γραμμικού κατακερματισμού είναι ιδιαίτερα χρήσιμη και αποδοτική για την εξαγωγή(αναζήτηση συμμετέχοντα στη ψηφοφορία) και εισαγωγή πληροφοριών στη συγκεκριμένη δομή, 
        καθώς επιτυγχάνεται σε  χρόνο Ο(1).
    
        Γενικά, όλοι οι κανόνες του linear hashing υλοποιούνται στο αρχείο LH_Implementation.c.

    - Σχετικά με τον σχεδιασμό της δομής inverted index list: 

        Στην αρχή γίνεται αρχικοποίηση του struct, listpointers το οποίο περιέχει δύο δείκτες σε listnode, έναν που δείχνει την αρχή έναν που δείχνει στο τέλος της λίστας,
    έτσι ώστε να γίνεται σε χρόνο Ο(1) η εισαγωγή στοιχείου στη λίστα.
        Το struct listnode περιέχει έναν ακέραιο (zip_code) και δύο δείκτες. Ο ένας δείκτης δείχνει τον επόμενο κόμβο της λίστας (είναι τύπου listnode *), ενώ ο άλλος δείχνει 
    σε struct extended list pointers. Η δομή αυτή περιέχει πληροφορίες σχετικά με τη λίστα που επεκτείνει τον κόμβο της βασικής και περιέχει τα pins που αντιστοιχούν στον
    συγκεκριμένο ταχυδρομικό κώδικα. Όπως και το struct list_pointers έτσι και το struct extended_listpointers περιέχει δύο δείκτες που δείχνουν ένας στην αρχή και ένας 
    στο τέλος της λίστας, για τη διευκόλυνση της εισαγωγής ενός στοιχείου.
        Οι κόμβοι τύπου listnode χρησιμεύουν για την αναπαράσταση της βασικής λίστας, η οποία περιέχει τους ταχυδρομκούς κωδικούς των συμμετεχόντων.
    
    -> Εισαγωγή zip_code στη λίστα

    Αν ο κώδικας zip_code δεν υπάρχει στην λίστα ήδη, τότε προστίθεται στο τέλος της. Αν υπάρχει ήδη τότε δεν γίνεται καμία ενέργεια.

    -> Εισαγωγή pin στη λίστα

    Αν ο ταχυδρομικός κώδικας υπάρχει ήδη, τότε απλά βρίσκουμε τον κόμβο που περιέχει αυτόν τον ταχυδρομικό κώδικα και προσθέτουμε το pin στη λίστα που εκτείνεται από extended-
    listpointers.
    Αν δεν υπάρχει, τον προσθέτουμε στη main list και έπειτα αρχικοποιούμε το struct extended list pointers και εισάγουμε το pin.


    - Σχετικά με την διαχείριση των commands της εφαρμογής

        Οι εντολές λαμβάνονται ως strings με την βοήθεια της fgets,η οποία παίρνει το string από τον χρήστη και της συνάρτησης strtok η οποία χωρίζει το string σε λέξεις (separator = ' ' (space)).
        Ο χαρακτήρας '\n' είτε αφαιρείται από το τέλος της λέξης, είτε ελέγχεται (στην περίπτωση που η εντολή είναι λέξη) μαζί με αυτός. Μέχρι να δοθεί η εντολή exit 
    με την οποία τερματίζει το πρόγραμμα, μπορούν να δίνονται οι υπόλοιπες εντολές. Για να εντοπίσουμε ποια εντολή πρέπει να εκτελεστεί, χρησιμοποιείται η συνάρτηση 
    strcomp η οποία συγκρίνει το string που δόθηκε με το string που δίνεται στη συνάρτηση σαν δεύτερο argument. Αν ταυτίζονται τότε καλείται η κατάλληλη συνάρτηση για να 
    εκτελεστεί η ενέργεια που είναι ανάλογη της εντολής. Το output των συναρτήσεων ακολουθεί τους κανόνες μορφοποίησης που δόθηκαν.


## ΠΑΡΑΔΟΧΕΣ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ

        1. Ο αρχικός αριθμός των buckets που περιέχει το hash table, ορίζεται από τη σταθερά m που γίνεται #define στο αρχείο linear_hashing.h.
        2. Δεν μπορεί να λειτούργήσει το πρόγραμμα, αν τα flags δοθούν τυχαία. Πρέπει να τρέξει η εντολή: 
        ./mvote -f registeredvoters -b bucketentries
        3. Για την εισαγωγή των εντολών που θα αντλούν πληροφορίες από τις δομές που έχουν αρχικοποιηθεί, ο χρήστης πρέπει να πληκτρολογεί 
        την εντολή και στη συνέχεια enter.


    - Σχετικά με την εκτέλεση του προγράμματος

    Εχω δημιουργήσει ένα αρχειο makefile το οποίο δημιουργέι τα αντικειμενικά αρχεία, στη συνέχεια τα συνδέει και δημιουργεί το τελικό εκτελέσιμο αρχείο με
    όνομα mvote.
    Το αρχείο Initialize_Data.c χρησιμοποιείται για την διαχείρηση των flags και την αρχικοποίηση των δομών hash table και της λίστας με τους ταχυδρομικούς κώδικες.
    Τα αρχεία LH_Implementation.c και linear_hashing.h αφορούν την δομή και τις συναρτήσεις για το hash table και την υλοποίηση του linear hashing.
    Τα αρχεία List_Implementation.c και inverted_index.h αφορούν την δομή της λίστα με τους ταχυδρομικούς κώδικους και τις αντίστοιχες συναρτήσεις της.
    Τα αρχέια App_Functions.c και functions.h αφορούν τη διαχείρηση των εντολών που δίνει ο χρήστης κατά την διάρκεια της εφαρμογής.
    Το αρχείο data.h περιέχει τις δηλώσεις των structs που χρησιμοποιούνται σε όλη την εφαρμογή και αξιοποιέιται από ολα τα υπόλοιπα αρχέια.

    Με την εκτέλεση της εντολής make στο τερματικό, δημιουργείται το mvote και είναι έτοιμο για εκτέλεση : ./mvote -f registeredvoters -b bucketentries